Total: 566 samples
     499  88.2%  88.2%      566 100.0% runner
      55   9.7%  97.9%       55   9.7% __strcmp_sse42
       7   1.2%  99.1%       35   6.2% SortedList_insert
       4   0.7%  99.8%       32   5.7% SortedList_lookup
       1   0.2% 100.0%        1   0.2% _init
       0   0.0% 100.0%      566 100.0% __clone
       0   0.0% 100.0%      566 100.0% start_thread
ROUTINE ====================== runner in /u/eng/class/classboy/test/UCLA-CS111/project2b/lab2_list.c
   499    566 Total samples (flat / cumulative)
     .      .   27: int my_hash(const char *str){
     .      .   28: 	int val = *str;
     .      .   29: 	return val;
     .      .   30: }
     .      .   31: 
---
     .      .   32: void* runner(void* temp){
     .      .   33: 	int my_start = *((int *) temp);
     .      .   34: 	int my_tid = my_start/num_iterations;
     .      .   35: 	int i;
     .      .   36: 	struct timespec s_time, e_time;
     .      .   37: 	My_Sublist *temp_sublist;
     .      .   38: 
     .      .   39: 	for(i = my_start; i < my_start + num_iterations; i++){
     .      .   40: 		temp_sublist = &my_list[my_hash(my_list_ele[i].key)%num_lists];
     .      .   41: 		switch(my_lock){
     .      .   42: 			case 'n':
     .      .   43: 			{
     .      .   44: 				SortedList_insert(&(temp_sublist->m_list), &my_list_ele[i]);
     .      .   45: 				break;
     .      .   46: 			}
     .      .   47: 			case 's':
     .      .   48: 			{
   308    308   49: 				while(__sync_lock_test_and_set(&(temp_sublist->my_spin), 1));
     .     35   50: 				SortedList_insert(&(temp_sublist->m_list), &my_list_ele[i]);
     .      .   51: 				__sync_lock_release(&(temp_sublist->my_spin));
     .      .   52: 				break;
     .      .   53: 			}
     .      .   54: 			case 'm':
     .      .   55: 			{
     .      .   56: 				clock_gettime(CLOCK_MONOTONIC, &s_time);
     .      .   57: 				pthread_mutex_lock(&(temp_sublist->my_mutex));
     .      .   58: 				clock_gettime(CLOCK_MONOTONIC, &e_time);
     .      .   59: 
     .      .   60: 				long long temp_time = (e_time.tv_sec - s_time.tv_sec) * 1000000000;
     .      .   61: 				temp_time += e_time.tv_nsec;
     .      .   62: 				temp_time -= s_time.tv_nsec;
     .      .   63: 				mutex_time[my_tid] += temp_time;
     .      .   64: 
     .      .   65: 				SortedList_insert(&(temp_sublist->m_list), &my_list_ele[i]);
     .      .   66: 				pthread_mutex_unlock(&(temp_sublist->my_mutex));
     .      .   67: 				break;
     .      .   68: 			}
     .      .   69: 		}
     .      .   70: 	}
     .      .   71: 
     .      .   72: 	int len = 0;
     .      .   73: 	switch(my_lock){
     .      .   74: 		case 'n':
     .      .   75: 		{
     .      .   76: 			for (i = 0; i < num_lists; i++) {
     .      .   77: 				if((len = SortedList_length(&(my_list[i].m_list))) < 0){
     .      .   78: 					break;
     .      .   79: 				}
     .      .   80: 			}
     .      .   81: 			break;
     .      .   82: 		}
     .      .   83: 		case 's':
     .      .   84: 		{
     .      .   85: 			for(i = 0; i < num_lists; i++){
     .      .   86: 				while(__sync_lock_test_and_set(&(my_list[i].my_spin), 1));
     .      .   87: 			}
     .      .   88: 			for(i = 0; i < num_lists; i++){
     .      .   89: 				if((len = SortedList_length(&(my_list[i].m_list))) < 0){
     .      .   90: 					break;
     .      .   91: 				}
     .      .   92: 			}
     .      .   93: 			for(i = 0; i < num_lists; i++){
     .      .   94: 				__sync_lock_release(&(my_list[i].my_spin));
     .      .   95: 			}
     .      .   96: 			break;
     .      .   97: 		}
     .      .   98: 		case 'm':
     .      .   99: 		{
     .      .  100: 			clock_gettime(CLOCK_MONOTONIC, &s_time);
     .      .  101: 			for (i = 0; i < num_lists; i++){
     .      .  102: 				pthread_mutex_lock(&my_list[i].my_mutex);
     .      .  103: 			}
     .      .  104: 			clock_gettime(CLOCK_MONOTONIC, &e_time);
     .      .  105: 
     .      .  106: 			long long temp_time = (e_time.tv_sec - s_time.tv_sec) * 1000000000;
     .      .  107: 			temp_time += e_time.tv_nsec;
     .      .  108: 			temp_time -= s_time.tv_nsec;
     .      .  109: 			mutex_time[my_tid] += temp_time;
     .      .  110: 			
     .      .  111: 			for (i = 0; i < num_lists; i++){
     .      .  112: 				if((len = SortedList_length(&my_list[i].m_list)) < 0){
     .      .  113: 					break;
     .      .  114: 				}
     .      .  115: 			}
     .      .  116: 
     .      .  117: 			for (i = 0; i < num_lists; i++){
     .      .  118: 				pthread_mutex_unlock(&my_list[i].my_mutex);
     .      .  119: 			}
     .      .  120: 			break;
     .      .  121: 		}
     .      .  122: 
     .      .  123: 	}
     .      .  124: 
     .      .  125: 	if(len < 0){
     .      .  126: 		fprintf(stderr, "Error: list corruption len incorrect\nyield: %d  lock: %c  threads: %d  iter: %d\n"
     .      .  127: 			, opt_yield, my_lock, num_threads, num_iterations);
     .      .  128: 		exit(2);
     .      .  129: 	}
     .      .  130: 
     .      .  131: 	SortedListElement_t* temp_ele = NULL;
     .      .  132: 	for(i = my_start; i < my_start + num_iterations; i++){
     .      .  133: 		temp_sublist = &my_list[my_hash(my_list_ele[i].key)%num_lists];
     .      .  134: 		switch(my_lock){
     .      .  135: 			case 'n':
     .      .  136: 			{
     .      .  137: 				if(!(temp_ele = SortedList_lookup(&(temp_sublist->m_list), my_list_ele[i].key))){
     .      .  138: 					fprintf(stderr, "Error: list corruption and element disappear\nyield: %d  lock: %c  threads: %d  iter: %d\n"
     .      .  139: 						, opt_yield, my_lock, num_threads, num_iterations);
     .      .  140: 					exit(2);
     .      .  141: 				}
     .      .  142: 				if(SortedList_delete(temp_ele)){
     .      .  143: 					fprintf(stderr, "Error: list corruption and cannot delete\nyield: %d  lock: %c  threads: %d  iter: %d\n"
     .      .  144: 						, opt_yield, my_lock, num_threads, num_iterations);
     .      .  145: 					exit(2);
     .      .  146: 				}
     .      .  147: 				break;
     .      .  148: 			}
     .      .  149: 			case 'm':
     .      .  150: 			{
     .      .  151: 				clock_gettime(CLOCK_MONOTONIC, &s_time);
     .      .  152: 				pthread_mutex_lock(&(temp_sublist->my_mutex));
     .      .  153: 				clock_gettime(CLOCK_MONOTONIC, &e_time);
     .      .  154: 
     .      .  155: 				long long temp_time = (e_time.tv_sec - s_time.tv_sec) * 1000000000;
     .      .  156: 				temp_time += e_time.tv_nsec;
     .      .  157: 				temp_time -= s_time.tv_nsec;
     .      .  158: 				mutex_time[my_tid] += temp_time;
     .      .  159: 
     .      .  160: 				if(!(temp_ele = SortedList_lookup(&(temp_sublist->m_list), my_list_ele[i].key))){
     .      .  161: 					fprintf(stderr, "Error: list corruption and element disappear\nyield: %d  lock: %c  threads: %d  iter: %d\n"
     .      .  162: 						, opt_yield, my_lock, num_threads, num_iterations);
     .      .  163: 					exit(2);
     .      .  164: 				}
     .      .  165: 				if(SortedList_delete(temp_ele)){
     .      .  166: 					fprintf(stderr, "Error: list corruption and cannot delete\nyield: %d  lock: %c  threads: %d  iter: %d\n"
     .      .  167: 						, opt_yield, my_lock, num_threads, num_iterations);
     .      .  168: 					exit(2);
     .      .  169: 				}
     .      .  170: 				pthread_mutex_unlock(&(temp_sublist->my_mutex));
     .      .  171: 				break;
     .      .  172: 			}
     .      .  173: 			case 's':
     .      .  174: 			{
   191    191  175: 				while(__sync_lock_test_and_set(&(temp_sublist->my_spin), 1));
     .     32  176: 				if(!(temp_ele = SortedList_lookup(&temp_sublist->m_list, my_list_ele[i].key))){
     .      .  177: 					fprintf(stderr, "Error: list corruption and element disappear\nyield: %d  lock: %c  threads: %d  iter: %d\n"
     .      .  178: 						, opt_yield, my_lock, num_threads, num_iterations);
     .      .  179: 					exit(2);
     .      .  180: 				}
     .      .  181: 				if(SortedList_delete(temp_ele)){
     .      .  182: 					fprintf(stderr, "Error: list corruption and cannot delete\nyield: %d  lock: %c  threads: %d  iter: %d\n"
     .      .  183: 						, opt_yield, my_lock, num_threads, num_iterations);
     .      .  184: 					exit(2);
     .      .  185: 				}
     .      .  186: 				__sync_lock_release(&(temp_sublist->my_spin));
     .      .  187: 				break;
     .      .  188: 			}
     .      .  189: 		}
     .      .  190: 
     .      .  191: 	}
     .      .  192: 	return NULL;
     .      .  193: }
---
     .      .  194: 
     .      .  195: void handler(){
     .      .  196: 	fprintf(stderr, "Error: Segmentation fault\n");
     .      .  197: 	free(my_list_ele);
     .      .  198: 	free(my_list);
ROUTINE ====================== runner in /u/eng/class/classboy/test/UCLA-CS111/project2b/lab2_list.c
   499    566 Total samples (flat / cumulative)
     .      .   27: int my_hash(const char *str){
     .      .   28: 	int val = *str;
     .      .   29: 	return val;
     .      .   30: }
     .      .   31: 
---
     .      .   32: void* runner(void* temp){
     .      .   33: 	int my_start = *((int *) temp);
     .      .   34: 	int my_tid = my_start/num_iterations;
     .      .   35: 	int i;
     .      .   36: 	struct timespec s_time, e_time;
     .      .   37: 	My_Sublist *temp_sublist;
     .      .   38: 
     .      .   39: 	for(i = my_start; i < my_start + num_iterations; i++){
     .      .   40: 		temp_sublist = &my_list[my_hash(my_list_ele[i].key)%num_lists];
     .      .   41: 		switch(my_lock){
     .      .   42: 			case 'n':
     .      .   43: 			{
     .      .   44: 				SortedList_insert(&(temp_sublist->m_list), &my_list_ele[i]);
     .      .   45: 				break;
     .      .   46: 			}
     .      .   47: 			case 's':
     .      .   48: 			{
   308    308   49: 				while(__sync_lock_test_and_set(&(temp_sublist->my_spin), 1));
     .     35   50: 				SortedList_insert(&(temp_sublist->m_list), &my_list_ele[i]);
     .      .   51: 				__sync_lock_release(&(temp_sublist->my_spin));
     .      .   52: 				break;
     .      .   53: 			}
     .      .   54: 			case 'm':
     .      .   55: 			{
     .      .   56: 				clock_gettime(CLOCK_MONOTONIC, &s_time);
     .      .   57: 				pthread_mutex_lock(&(temp_sublist->my_mutex));
     .      .   58: 				clock_gettime(CLOCK_MONOTONIC, &e_time);
     .      .   59: 
     .      .   60: 				long long temp_time = (e_time.tv_sec - s_time.tv_sec) * 1000000000;
     .      .   61: 				temp_time += e_time.tv_nsec;
     .      .   62: 				temp_time -= s_time.tv_nsec;
     .      .   63: 				mutex_time[my_tid] += temp_time;
     .      .   64: 
     .      .   65: 				SortedList_insert(&(temp_sublist->m_list), &my_list_ele[i]);
     .      .   66: 				pthread_mutex_unlock(&(temp_sublist->my_mutex));
     .      .   67: 				break;
     .      .   68: 			}
     .      .   69: 		}
     .      .   70: 	}
     .      .   71: 
     .      .   72: 	int len = 0;
     .      .   73: 	switch(my_lock){
     .      .   74: 		case 'n':
     .      .   75: 		{
     .      .   76: 			for (i = 0; i < num_lists; i++) {
     .      .   77: 				if((len = SortedList_length(&(my_list[i].m_list))) < 0){
     .      .   78: 					break;
     .      .   79: 				}
     .      .   80: 			}
     .      .   81: 			break;
     .      .   82: 		}
     .      .   83: 		case 's':
     .      .   84: 		{
     .      .   85: 			for(i = 0; i < num_lists; i++){
     .      .   86: 				while(__sync_lock_test_and_set(&(my_list[i].my_spin), 1));
     .      .   87: 			}
     .      .   88: 			for(i = 0; i < num_lists; i++){
     .      .   89: 				if((len = SortedList_length(&(my_list[i].m_list))) < 0){
     .      .   90: 					break;
     .      .   91: 				}
     .      .   92: 			}
     .      .   93: 			for(i = 0; i < num_lists; i++){
     .      .   94: 				__sync_lock_release(&(my_list[i].my_spin));
     .      .   95: 			}
     .      .   96: 			break;
     .      .   97: 		}
     .      .   98: 		case 'm':
     .      .   99: 		{
     .      .  100: 			clock_gettime(CLOCK_MONOTONIC, &s_time);
     .      .  101: 			for (i = 0; i < num_lists; i++){
     .      .  102: 				pthread_mutex_lock(&my_list[i].my_mutex);
     .      .  103: 			}
     .      .  104: 			clock_gettime(CLOCK_MONOTONIC, &e_time);
     .      .  105: 
     .      .  106: 			long long temp_time = (e_time.tv_sec - s_time.tv_sec) * 1000000000;
     .      .  107: 			temp_time += e_time.tv_nsec;
     .      .  108: 			temp_time -= s_time.tv_nsec;
     .      .  109: 			mutex_time[my_tid] += temp_time;
     .      .  110: 			
     .      .  111: 			for (i = 0; i < num_lists; i++){
     .      .  112: 				if((len = SortedList_length(&my_list[i].m_list)) < 0){
     .      .  113: 					break;
     .      .  114: 				}
     .      .  115: 			}
     .      .  116: 
     .      .  117: 			for (i = 0; i < num_lists; i++){
     .      .  118: 				pthread_mutex_unlock(&my_list[i].my_mutex);
     .      .  119: 			}
     .      .  120: 			break;
     .      .  121: 		}
     .      .  122: 
     .      .  123: 	}
     .      .  124: 
     .      .  125: 	if(len < 0){
     .      .  126: 		fprintf(stderr, "Error: list corruption len incorrect\nyield: %d  lock: %c  threads: %d  iter: %d\n"
     .      .  127: 			, opt_yield, my_lock, num_threads, num_iterations);
     .      .  128: 		exit(2);
     .      .  129: 	}
     .      .  130: 
     .      .  131: 	SortedListElement_t* temp_ele = NULL;
     .      .  132: 	for(i = my_start; i < my_start + num_iterations; i++){
     .      .  133: 		temp_sublist = &my_list[my_hash(my_list_ele[i].key)%num_lists];
     .      .  134: 		switch(my_lock){
     .      .  135: 			case 'n':
     .      .  136: 			{
     .      .  137: 				if(!(temp_ele = SortedList_lookup(&(temp_sublist->m_list), my_list_ele[i].key))){
     .      .  138: 					fprintf(stderr, "Error: list corruption and element disappear\nyield: %d  lock: %c  threads: %d  iter: %d\n"
     .      .  139: 						, opt_yield, my_lock, num_threads, num_iterations);
     .      .  140: 					exit(2);
     .      .  141: 				}
     .      .  142: 				if(SortedList_delete(temp_ele)){
     .      .  143: 					fprintf(stderr, "Error: list corruption and cannot delete\nyield: %d  lock: %c  threads: %d  iter: %d\n"
     .      .  144: 						, opt_yield, my_lock, num_threads, num_iterations);
     .      .  145: 					exit(2);
     .      .  146: 				}
     .      .  147: 				break;
     .      .  148: 			}
     .      .  149: 			case 'm':
     .      .  150: 			{
     .      .  151: 				clock_gettime(CLOCK_MONOTONIC, &s_time);
     .      .  152: 				pthread_mutex_lock(&(temp_sublist->my_mutex));
     .      .  153: 				clock_gettime(CLOCK_MONOTONIC, &e_time);
     .      .  154: 
     .      .  155: 				long long temp_time = (e_time.tv_sec - s_time.tv_sec) * 1000000000;
     .      .  156: 				temp_time += e_time.tv_nsec;
     .      .  157: 				temp_time -= s_time.tv_nsec;
     .      .  158: 				mutex_time[my_tid] += temp_time;
     .      .  159: 
     .      .  160: 				if(!(temp_ele = SortedList_lookup(&(temp_sublist->m_list), my_list_ele[i].key))){
     .      .  161: 					fprintf(stderr, "Error: list corruption and element disappear\nyield: %d  lock: %c  threads: %d  iter: %d\n"
     .      .  162: 						, opt_yield, my_lock, num_threads, num_iterations);
     .      .  163: 					exit(2);
     .      .  164: 				}
     .      .  165: 				if(SortedList_delete(temp_ele)){
     .      .  166: 					fprintf(stderr, "Error: list corruption and cannot delete\nyield: %d  lock: %c  threads: %d  iter: %d\n"
     .      .  167: 						, opt_yield, my_lock, num_threads, num_iterations);
     .      .  168: 					exit(2);
     .      .  169: 				}
     .      .  170: 				pthread_mutex_unlock(&(temp_sublist->my_mutex));
     .      .  171: 				break;
     .      .  172: 			}
     .      .  173: 			case 's':
     .      .  174: 			{
   191    191  175: 				while(__sync_lock_test_and_set(&(temp_sublist->my_spin), 1));
     .     32  176: 				if(!(temp_ele = SortedList_lookup(&temp_sublist->m_list, my_list_ele[i].key))){
     .      .  177: 					fprintf(stderr, "Error: list corruption and element disappear\nyield: %d  lock: %c  threads: %d  iter: %d\n"
     .      .  178: 						, opt_yield, my_lock, num_threads, num_iterations);
     .      .  179: 					exit(2);
     .      .  180: 				}
     .      .  181: 				if(SortedList_delete(temp_ele)){
     .      .  182: 					fprintf(stderr, "Error: list corruption and cannot delete\nyield: %d  lock: %c  threads: %d  iter: %d\n"
     .      .  183: 						, opt_yield, my_lock, num_threads, num_iterations);
     .      .  184: 					exit(2);
     .      .  185: 				}
     .      .  186: 				__sync_lock_release(&(temp_sublist->my_spin));
     .      .  187: 				break;
     .      .  188: 			}
     .      .  189: 		}
     .      .  190: 
     .      .  191: 	}
     .      .  192: 	return NULL;
     .      .  193: }
---
     .      .  194: 
     .      .  195: void handler(){
     .      .  196: 	fprintf(stderr, "Error: Segmentation fault\n");
     .      .  197: 	free(my_list_ele);
     .      .  198: 	free(my_list);
